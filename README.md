# 编译优化（上）

### 内容摘要
* 预处理
* 编译和链接过程
* 静态编译和动态编译
* CMake和Make
* 编译耗时分析
* 编译优化手段
* 涉及到的概念一览

### 预处理
可以粗略的认为只做了一件事情，那就是“宏展开”，也就是对那些#。。。的命令的一种展开，看例子。
```
#include <stdio.h>
#define MAX 10

int main() {
	int a = MAX;
#ifdef HAHA
	a++;
#endif
	printf("a = %d \n");
	return 0;
}
```
执行 ```gcc test3.c -E -o test3.i``` 查看test3.i

### 编译和链接过程
#### 单个cpp文件编译过程
  以下面的文件为例。
```
// test1.c

int g_a = 1;            //定义有初始值全局变量
int g_b;                //定义无初始值全局变量
static int g_c;         //定义全局static变量
extern int g_x;         //声明全局变量
extern int sub();   //函数声明

int sum(int m, int n) {     //函数定义
    return m+n;
}
int main(int argc, char* argv[]) {
    static int s_a = 0;     //局部static变量
    int l_a = 0;                //局部非static变量
    sum(g_a,g_b);
    return 0;
}
```
  其中，static，非static变量与全局，非全局的四种组合的效果如下
* 非 static 全局变量表示这个变量存在于程序执行的整个生命周期，同时可以被本源码文件之外的其他文件访问到。
* static 全局变量表示这个变量存在于程序执行的整个生命周期，但是只能被本源码文件的函数访问到。
* 非 static 局部变量表示，这个变量只在本变量所在的函数的执行上下文中存在（实际上这种变量是在函数执行栈的函数栈帧中）
* static 局部变量其实属于全部变量的范畴，它存在于程序执行的整个生命周期，但是作用域被局限在定义这个变量的代码块中（大括号包含的范围）
 
执行```gcc -c test1.c -o test1.o && nm test1.o```编译成目标文件,得到下面的结果 
 ```
0000000000000000 D g_a
0000000000000004 C g_b
0000000000000000 b g_c
                 U g_x // fake
0000000000000014 T main
0000000000000004 b s_a.1843
0000000000000000 T sum
  ```
  第一列是变量在所在段的相对地址，我们看到 g_a 和 g_c 的相对地址是相同的，这并不冲突，因为他们处于不同的段中（ D 和 b 表示它们在目标文件中处于不同的段中)。
  第二列表示变量所处的段的类型，比如 D 段就是数据段，专门存放有初始值的全局变量，T 段表示代码段，所有的代码编译后的指令都放到这个段中。同一个段中的变量相对地址是不能重复的。
  第三列表示变量的名字，这里我们看到局部的静态变量名字被编译器修改为 s_a.1597。s_a 是一个局部静态变量，作用域限制在定义它的代码块中，所以我们可以在不同的作用域中声明相同名字的局部静态变量，比如我们可以在sum函数中声明另外一个 s_a。但是我们上面提过，局部静态变量属于全局变量的范畴，它是存在于程序运行的整个生命周期的，所以为了支持这个功能，编译器对这种局部的静态变量名字加了一个后缀以便标识不同的局部静态变量。
  g_x 没有地址是因为变量和函数的声明本质上是给编译器一个承诺，告诉编译器虽然在本文件中没有这个变量或者函数定义，但是在其他文件中一定有，所以当编译器发现程序需要读取这个变量对应的数据，但是在源文件中找不到的时候，就会把这个变量放在一个特殊的段（段类型为 U）里面，表示后续链接的时候需要在后面的目标文件或者链接库中找到这个变量，然后链接成为可执行二进制文件。
  
#### 多个cpp文件编译链接过程
下面是test2.c文件, 执行```gcc test.o test2.o -o test; nm test```
```
// test2.c

int g_x = 100;
int sub() {}
```
执行后链接test1.o和test2.o，即```gcc test1.o test2.o -o test; nm test```得到下面的内容
```
0000000000601038 B __bss_start
0000000000601038 b completed.7594
0000000000601020 D __data_start
0000000000601020 W data_start
0000000000400410 t deregister_tm_clones
0000000000400490 t __do_global_dtors_aux
0000000000600e18 t __do_global_dtors_aux_fini_array_entry
0000000000601028 D __dso_handle
0000000000600e28 d _DYNAMIC
0000000000601038 D _edata
0000000000601048 B _end
00000000004005a4 T _fini
00000000004004b0 t frame_dummy
0000000000600e10 t __frame_dummy_init_array_entry
0000000000400728 r __FRAME_END__
0000000000601030 D g_a
0000000000601044 B g_b
000000000060103c b g_c
0000000000601000 d _GLOBAL_OFFSET_TABLE_
                 w __gmon_start__
00000000004005b4 r __GNU_EH_FRAME_HDR
0000000000601034 D g_x
0000000000400390 T _init
0000000000600e18 t __init_array_end
0000000000600e10 t __init_array_start
00000000004005b0 R _IO_stdin_used
                 w _ITM_deregisterTMCloneTable
                 w _ITM_registerTMCloneTable
0000000000600e20 d __JCR_END__
0000000000600e20 d __JCR_LIST__
                 w _Jv_RegisterClasses
00000000004005a0 T __libc_csu_fini
0000000000400530 T __libc_csu_init
                 U __libc_start_main@@GLIBC_2.2.5
00000000004004ea T main
0000000000400450 t register_tm_clones
0000000000601040 b s_a.1843
00000000004003e0 T _start
000000000040051c T sub
00000000004004d6 T sum
0000000000601038 D __TMC_END__
```
  之前在第一个源文件中声明的变量 g_x 和声明的函数 sub 最终在第二个目标文件中找到了定义；其次，在不同目标文件中定义的变量，比如 g_a, g_x 都会放在了数据段中(段类型为 D)；还有，之前在目标文件中变量的相对地址全部变成了绝对地址。
  编译是以一个个独立的文件作为单元的，一个文件就会编译出一个目标文件。因此编译只负责本单元的那些事，而对外部的事情一概不理会，在这一步里，我们可以调用一个函数而不必给出这个函数的定义，但是要在调用前得到这个函数的声明。
  链接过程分为两步，第一步是合并所有目标文件的段，并调整段偏移和段长度，合并符号表，分配内存地址；第二步是链接的核心，进行符号的重定位。
  (1)合并段
       所有相同属性的段进行合并，组织在一个页面上，这样更节省空间。如.text段的权限是可读可执行，.rodata段也是可读可执行，所以将两者合并组织在一个页面上；同理合并.data段和.bss段。
  (2)合并符号表
       链接阶段只处理所有obj文件的global符号，local符号不作任何处理。
  (3)符号解析
       符号解析指的是所有引用符号的地方都要找到符号定义的地方。
  (4)分配内存地址
       在编译过程中不分配地址（给的是零地址和偏移），直到符号解析完成以后才分配地址。
  静态和动态链接都是链接，都会经过上述过程。
  (5)符号重定位
       因为在编译过程中不分配地址，所以在目标文件所以数据出现的地方都给的是零地址，所有函数调用的地方给的是相对于下一条指令的地址的偏移量。在符号重定位时，要把分配的地址回填到数据和函数调用出现   的地方，而且对于数据而言填的是绝对地址，而对函数调用而言填的是偏移量。
       
* 头文件
  头文件的作用就是被其他的.cpp包含进去的。它们本身并不参与编译，但它们的内容却在多个.cpp文件中得到了编译。如果在头文件中放了定义，头文件被多个cpp文件包含后，那么也就相当于在多个文件中出现了对于一个符号（变量或函数）的定义，纵然这些定义都是相同的，但对于编译器来说，这样做不合法。但是有以下几个例外。
  ```
  multiple definition 见 test4
  ```
  一，头文件中可以写const对象的定义。因为全局的const对象默认是没有extern的声明的，所以它只在当前文件中有效。把这样的对象写进头文件中，即使它被包含到其他多个.cpp文件中，这个对象也都只在包含它的 那个文件中有效，对其他文件来说是不可见的，所以便不会导致多重定义。同理，static对象的定义也可以放进头文件。
  二，头文件中可以写内联函数（inline）的定义。因为inline函数是需要编译器在遇到它的地方把它展开，而并非是普通函数那样可以先声明再链接的（内联函数不会链接），所以编译器就需要在编译时看到内联函数的完整定义才行。如果内联函数像普通函数一样只能定义一次的话，这事儿就难办了。因为在 一个文件中还好，我可以把内联函数的定义写在最开始，这样可以保证后面使用的时候都可以见到定义；但是，如果我在其他的文件中还使用到了这个函数那怎么办 呢？这几乎没什么太好的解决办法，因此C++规定，内联函数可以在程序中定义多次，只要内联函数在一个.cpp文件中只出现一次，并且在所有的.cpp文 件中，这个内联函数的定义是一样的，就能通过编译。那么显然，把内联函数的定义放进一个头文件中是非常明智的做法。
  三，头文件中可以写类（class）的定义。因为在程序中创建一个类的对象时，编译器只有在这个类的定义完全可见的情况下，才能知道这个类的对象应该如何布局。一般的做法是，把类的定义放在头文件中，而把函数成员的实现代码放在一个.cpp文件中。还有另一种办法就是直接把函数成员的实现代码也写进类定义里面。在C++的类中，如果函数成员在类的定义体中被定义，那么编译器会视这个函数为内联的。因此，把函数成员的定义写进类定义体，一起放进头文件中，是合法的。注意一下，如果把函数成员的定义写在类定义的头文件中，而没有写进类定义中， 这是不合法的，因为这个函数成员此时就不是内联的了。一旦头文件被两个或两个以上的.cpp文件包含，这个函数成员就被重定义了。

### 静态编译和动态编译
```
#include <stdio.h>
#include <string.h>

int main(int argc, char* argv[]) {
    char buf[32];
    strncpy(buf, "Hello, World\n", 32);
    printf("%s",buf);
}
```
gcc test5.c -o test5 && nm test5
ldd test5

### 涉及到的概念一览
* 符号
* 段
* 目标文件，可执行文件
