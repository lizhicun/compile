# 编译优化（上）

### 内容摘要
* 编译和链接过程
* 静态编译和动态编译
* CMake和Make
* 编译耗时分析
* 编译优化手段
* 涉及到的概念一览

### 编译和链接过程
* 单个cpp文件编译过程
  以下面的文件为例。
```
// test1.c

int g_a = 1;            //定义有初始值全局变量
int g_b;                //定义无初始值全局变量
static int g_c;         //定义全局static变量
extern int g_x;         //声明全局变量
extern int sub();   //函数声明

int sum(int m, int n) {     //函数定义
    return m+n;
}
int main(int argc, char* argv[]) {
    static int s_a = 0;     //局部static变量
    int l_a = 0;                //局部非static变量
    sum(g_a,g_b);
    return 0;
}
```
  其中，static，非static变量与全局，非全局的四种组合的效果如下
* 非 static 全局变量表示这个变量存在于程序执行的整个生命周期，同时可以被本源码文件之外的其他文件访问到。
* static 全局变量表示这个变量存在于程序执行的整个生命周期，但是只能被本源码文件的函数访问到。
* 非 static 局部变量表示，这个变量只在本变量所在的函数的执行上下文中存在（实际上这种变量是在函数执行栈的函数栈帧中）
* static 局部变量其实属于全部变量的范畴，它存在于程序执行的整个生命周期，但是作用域被局限在定义这个变量的代码块中（大括号包含的范围）
  执行```gcc -c test1.c -o test1.o && nm test1.o```编译成目标文件,得到下面的结果 
 ```
0000000000000000 D g_a
0000000000000004 C g_b
0000000000000000 b g_c
0000000000000014 T main
0000000000000004 b s_a.1843
0000000000000000 T sum
  ```
  第一列是变量在所在段的相对地址，我们看到 g_a 和 g_c 的相对地址是相同的，这并不冲突，因为他们处于不同的段中（ D 和 b 表示它们在目标文件中处于不同的段中)。
  第二列表示变量所处的段的类型，比如 D 段就是数据段，专门存放有初始值的全局变量，T 段表示代码段，所有的代码编译后的指令都放到这个段中。同一个段中的变量相对地址是不能重复的。
  第三列表示变量的名字，这里我们看到局部的静态变量名字被编译器修改为 s_a.1597。s_a 是一个局部静态变量，作用域限制在定义它的代码块中，所以我们可以在不同的作用域中声明相同名字的局部静态变量，比如我们可以在sum函数中声明另外一个 s_a。但是我们上面提过，局部静态变量属于全局变量的范畴，它是存在于程序运行的整个生命周期的，所以为了支持这个功能，编译器对这种局部的静态变量名字加了一个后缀以便标识不同的局部静态变量。

  
* 多个cpp文件编译过程

### 涉及到的概念一览
* 符号
* 段
* 目标文件，可执行文件
